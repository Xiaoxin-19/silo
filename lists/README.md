# lists

`lists` 是一个基于 Go 泛型 (Generics) 实现的高性能双向链表库，旨在提供比标准库 `container/list` 更强类型安全、更高性能和更低内存占用的替代方案。

## 🚀 性能基准 (Benchmarks)

基于 Ryzen 7 4800H 的测试结果表明，`silo/lists` 在绝大多数场景下显著优于标准库。

### 📊 核心结论

1.  **速度更快**: 基础操作（追加、头部插入、队列操作）比标准库快 **40% ~ 100%**。
2.  **内存更省**: 节点内存占用减少 **50%+**。Silo 节点仅需 24 字节（64位系统），而标准库需要 48~56 字节。
3.  **遍历更优**: 得益于更紧凑的内存布局和更好的缓存局部性 (Cache Locality)，遍历速度快 **2 倍** 以上。
4.  **零开销**: 泛型避免了 `interface{}` 的装箱 (Boxing) 和拆箱 (Unboxing) 开销。

### 📈 详细对比 (100万数据量)

| 场景 | Silo (泛型) | StdLib (接口) | 提升幅度 | 说明 |
| :--- | :--- | :--- | :--- | :--- |
| **Append (Int)** | **36 ms** | 72 ms | 🚀 **2.0x** | 内存分配更少 |
| **Prepend (Int)** | **35 ms** | 69 ms | 🚀 **1.9x** | 头部插入 |
| **Iterate (遍历)** | **2.1 ms** | 4.9 ms | 🚀 **2.3x** | 缓存命中率更高 |
| **Queue (Ops)** | **44 ns** | 71 ns | 🚀 **1.6x** | 稳态吞吐量 |
| **Memory (Footprint)**| **~24 MB** | ~56 MB | 📉 **-57%** | 极大的内存节省 |

### ⚠️ 关于大对象 (Large Structs)

*   **存储值 (`LinkedList[BigStruct]`)**: 由于 Silo 采用内联存储，插入大对象会发生内存拷贝，性能可能低于存储接口的标准库。
*   **存储指针 (`LinkedList[*BigStruct]`)**: **强烈推荐**。此时 Silo 仅存储指针 (8 bytes)，性能回归最强状态，比标准库快 **20%+**。

## 💡 最佳实践

1.  **替代标准库**: 在任何需要双向链表的场景下，完全可以替代 `container/list`。
2.  **大对象存指针**: 如果元素结构体较大 (>32 bytes)，请使用 `LinkedList[*T]` 以避免拷贝开销。
3.  **Slice vs List**: 
    *   如果需要 O(1) 的头部插入/删除，或频繁在中间位置删除节点，请使用 `lists`。
    *   如果主要是尾部追加和随机访问，Go 原生的 **切片 (Slice)** 依然是性能之王。

## 📦 安装

```bash
go get silo/lists
```

> 需要 Go 1.18+ 以支持泛型。